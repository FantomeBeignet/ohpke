exception ValidationError of string
exception DeserializeError of string
exception EncapError of string
exception DecapError of string
exception DeriveKeyPairError of string

type id =
  [ `DHMKE_P256_HKDF_SHA256
  | `DHKEM_P384_HKDF_SHA384
  | `DHKEM_P521_HKDF_SHA512
  | `DHKEM_X25519_HKDF_SHA256
  | `DHKEM_X448_HKDF_SHA512 ]

let ids =
  [
    `DHMKE_P256_HKDF_SHA256;
    `DHKEM_P384_HKDF_SHA384;
    `DHKEM_P521_HKDF_SHA512;
    `DHKEM_X25519_HKDF_SHA256;
    `DHKEM_X448_HKDF_SHA512;
  ]

let id_value (id : id) : Cstruct.uint16 =
  match id with
  | `DHMKE_P256_HKDF_SHA256 -> 16
  | `DHKEM_P384_HKDF_SHA384 -> 17
  | `DHKEM_P521_HKDF_SHA512 -> 18
  | `DHKEM_X25519_HKDF_SHA256 -> 32
  | `DHKEM_X448_HKDF_SHA512 -> 33

module type KEM = sig
  val nsecret : int
  (** The length in bytes of a KEM shared secret produced by this KEM *)

  val nenc : int
  (** The length in bytes of an encapsulated key produced by this KEM *)

  val npk : int
  (** The length in bytes of an encoded public key for this KEM *)

  val nsk : int
  (** The length in bytes of an encoded private key for this KEM *)

  type secret

  val generate_keypair : unit -> secret * Cstruct.t
  (** Randomized algorithm to generate a key pair [(skX, pkX)] *)

  val derive_keypair : Cstruct.t -> secret * Cstruct.t
  (** [derive_keypair ikm] : deterministic algorithm to derive a key pair [(skX, pkX)] from the byte string [ikm], where [ikm] SHOULD have at least [nsk] bytes of entropy *)

  val serialize_public_key : Cstruct.t -> Cstruct.t
  (** [serialize_public_key pkX] Produce a byte string of length [npk] encoding the public key [pkX] *)

  val deserialize_public_key : Cstruct.t -> (Cstruct.t, string) result
  (** [deserialize_public_key pkXm] parses a byte string of length [npk] to recover a public key. This function can return a DeserializeError error upon [pkXm] deserialization failure *)

  val deserialize_public_key_exn : Cstruct.t -> Cstruct.t
  (** Same as [deserialize_public_key] but raises an exception instead of returning an [Error] *)

  val encap : Cstruct.t -> (Cstruct.t * Cstruct.t, string) result
  (** [encap pkR] : randomized algorithm to generate an ephemeral, fixed-length symmetric key (the KEM shared secret) and a fixed-length encapsulation of that key that can be decapsulated by the holder of the private key corresponding to [pkR]. This function can return an EncapError on encapsulation failure *)

  val encap_exn : Cstruct.t -> Cstruct.t * Cstruct.t
  (** Same as [encap] but raises an exception instead of returning an [Error] *)

  val decap : Cstruct.t -> secret -> (Cstruct.t, string) result
  (** [decap enc skR] : deterministic algorithm using the private key [skR] to recover the ephemeral symmetric key (the KEM shared secret) from its encapsulated representation [enc]. This function can return a DecapError on decapsulation failure *)

  val decap_exn : Cstruct.t -> secret -> Cstruct.t
  (** Same as [decap] but raises an exception instead of returning an [Error] *)

  val auth_encap : Cstruct.t -> secret -> (Cstruct.t * Cstruct.t, string) result
  (** [auth_encap pkR skS] : same as [encap], and the outputs encode an assurance that the KEM shared secret was generated by the holder of the private key [skS] *)

  val auth_encap_exn : Cstruct.t -> secret -> Cstruct.t * Cstruct.t
  (** Same as [auth_encap] but raises an exception instead of returning an [Error] *)

  val auth_decap :
    Cstruct.t -> secret -> Cstruct.t -> (Cstruct.t, string) result
  (** [auth_decap enc skR pkS] : same as [decap], and the recipient is assured that the KEM shared secret was generated by the holder of the private key [skS] *)

  val auth_decap_exn : Cstruct.t -> secret -> Cstruct.t -> Cstruct.t
  (** Same as [auth_decap] but raises an exception instead of returning an [Error] *)
end
